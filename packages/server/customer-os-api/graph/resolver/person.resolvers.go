package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/dataloader"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/generated"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/model"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/utils"
)

// PersonMerge is the resolver for the person_Merge field.
func (r *mutationResolver) PersonMerge(ctx context.Context, input model.PersonInput) (*model.Person, error) {
	defer func(start time.Time) {
		utils.LogMethodExecution(start, utils.GetFunctionName())
	}(time.Now())

	personEntity, error := r.Services.PersonService.Merge(ctx, mapper.MapPersonInputToEntity(&input))
	if error != nil {
		graphql.AddErrorf(ctx, "Failed to merge person")
		return nil, error
	}
	return mapper.MapEntityToPerson(personEntity), nil
}

// PersonUpdate is the resolver for the person_Update field.
func (r *mutationResolver) PersonUpdate(ctx context.Context, id string, update model.PersonUpdate) (*model.Person, error) {
	defer func(start time.Time) {
		utils.LogMethodExecution(start, utils.GetFunctionName())
	}(time.Now())

	personEntity, error := r.Services.PersonService.Update(ctx, mapper.MapPersonUpdateToEntity(id, &update))
	if error != nil {
		graphql.AddErrorf(ctx, "Failed to update person %s", id)
		return nil, error
	}
	return mapper.MapEntityToPerson(personEntity), nil
}

// PersonSetDefaultUser is the resolver for the person_SetDefaultUser field.
func (r *mutationResolver) PersonSetDefaultUser(ctx context.Context, id string, userID string) (*model.Person, error) {
	defer func(start time.Time) {
		utils.LogMethodExecution(start, utils.GetFunctionName())
	}(time.Now())

	personEntity, error := r.Services.PersonService.SetDefaultUser(ctx, id, userID)
	if error != nil {
		graphql.AddErrorf(ctx, "Failed to set default user for person %s", id)
		return nil, error
	}
	return mapper.MapEntityToPerson(personEntity), nil
}

// Users is the resolver for the users field.
func (r *personResolver) Users(ctx context.Context, obj *model.Person) ([]*model.PersonUser, error) {
	defer func(start time.Time) {
		utils.LogMethodExecution(start, utils.GetFunctionName())
	}(time.Now())

	userEntities, err := dataloader.For(ctx).GetUsersForPerson(ctx, obj.ID)
	if err != nil {
		graphql.AddErrorf(ctx, "Failed to get users for person %s", obj.ID)
		return nil, err
	}
	return mapper.MapEntitiesToPersonUsers(userEntities), nil
}

// PersonByEmailProvider is the resolver for the person_ByEmailProvider field.
func (r *queryResolver) PersonByEmailProvider(ctx context.Context, email string, provider string) (*model.Person, error) {
	defer func(start time.Time) {
		utils.LogMethodExecution(start, utils.GetFunctionName())
	}(time.Now())

	personEntity, err := r.Services.PersonService.GetPersonByEmailProvider(ctx, email, provider)
	if err != nil {
		graphql.AddErrorf(ctx, "Failed to get person by email and provider")
		return nil, err
	}
	return mapper.MapEntityToPerson(personEntity), nil
}

// PersonGetUsers is the resolver for the person_GetUsers field.
func (r *queryResolver) PersonGetUsers(ctx context.Context) ([]*model.PersonUser, error) {
	defer func(start time.Time) {
		utils.LogMethodExecution(start, utils.GetFunctionName())
	}(time.Now())

	dbUsers, err := r.Services.PersonService.GetUsers(ctx)
	if err != nil {
		graphql.AddErrorf(ctx, "Failed to get users")
		return nil, err
	}
	return mapper.MapEntitiesToPersonUsers(dbUsers), nil
}

// Person returns generated.PersonResolver implementation.
func (r *Resolver) Person() generated.PersonResolver { return &personResolver{r} }

type personResolver struct{ *Resolver }
