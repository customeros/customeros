package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/model"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/tracing"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/common"
	postgresEntity "github.com/openline-ai/openline-customer-os/packages/server/customer-os-postgres-repository/entity"
)

// GlobalCache is the resolver for the global_Cache field.
func (r *queryResolver) GlobalCache(ctx context.Context) (*model.GlobalCache, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "GlobalCache.global_Cache", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	response := &model.GlobalCache{}

	tenantName := common.GetTenantFromContext(ctx)
	userId := common.GetUserIdFromContext(ctx)
	userEmail := common.GetUserEmailFromContext(ctx)

	user, err := r.Services.UserService.GetById(ctx, userId)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "failed GlobalCache - find user by id")
		return nil, nil
	}
	response.User = mapper.MapEntityToUser(user)

	isOwner, err := r.Services.UserService.IsOwner(ctx, user.Id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "failed GlobalCache - is owner")
		return nil, nil
	}
	response.IsOwner = *isOwner

	if userEmail != "" {
		privateKey, err := r.Services.CommonServices.PostgresRepositories.GoogleServiceAccountKeyRepository.GetApiKeyByTenantService(ctx, tenantName, postgresEntity.GSUITE_SERVICE_PRIVATE_KEY)
		if err != nil {
			tracing.TraceErr(span, err)
			return nil, err
		}
		serviceEmail, err := r.Services.CommonServices.PostgresRepositories.GoogleServiceAccountKeyRepository.GetApiKeyByTenantService(ctx, tenantName, postgresEntity.GSUITE_SERVICE_EMAIL_ADDRESS)
		if err != nil {
			tracing.TraceErr(span, err)
			return nil, err
		}

		response.ActiveEmailTokens = []*model.GlobalCacheEmailToken{}
		response.InactiveEmailTokens = []*model.GlobalCacheEmailToken{}

		if privateKey != "" && serviceEmail != "" {
			response.ActiveEmailTokens = append(response.ActiveEmailTokens, &model.GlobalCacheEmailToken{
				Email:    userEmail,
				Provider: "google",
			})
		}

		oauthTokenList, err := r.Services.CommonServices.PostgresRepositories.OAuthTokenRepository.GetByTenant(ctx, tenantName)
		if err != nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "Failed GlobalCache - get gmail token needs manual refresh")
			return nil, nil
		}

		for _, oauthToken := range oauthTokenList {
			if !oauthToken.NeedsManualRefresh {
				response.ActiveEmailTokens = append(response.ActiveEmailTokens, &model.GlobalCacheEmailToken{Email: oauthToken.EmailAddress, Provider: oauthToken.Provider})
			} else {
				response.InactiveEmailTokens = append(response.InactiveEmailTokens, &model.GlobalCacheEmailToken{Email: oauthToken.EmailAddress, Provider: oauthToken.Provider})
			}
		}

		//response.ActiveEmailTokens = utils.UniqueSlicePtrElements(response.ActiveEmailTokens)
		//response.InactiveEmailTokens = utils.UniqueSlicePtrElements(response.InactiveEmailTokens)
	}

	response.GCliCache = r.Services.Cache.GetStates() //pre-populate with states

	minARRForecastValue, maxARRForecastValue, err := r.Services.OrganizationService.GetMinMaxRenewalForecastArr(ctx)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed GlobalCache - get min max arr forecast")
		return nil, nil
	}

	response.MinARRForecastValue = minARRForecastValue
	response.MaxARRForecastValue = maxARRForecastValue

	contractsExistForTenant, err := r.Services.ContractService.ContractsExistForTenant(ctx)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed GlobalCache - contracts exist for tenant")
		return nil, nil
	}

	response.ContractsExist = contractsExistForTenant

	tenantSettings, err := r.Services.CommonServices.TenantService.GetTenantSettings(ctx)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed GlobalCache - get tenant billing profiles")
		return nil, nil
	}

	if tenantSettings != nil && tenantSettings.LogoRepositoryFileId != "" {
		attachmentById, err := r.Services.AttachmentService.GetAttachmentById(ctx, tenantSettings.LogoRepositoryFileId)
		if err != nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "Failed GlobalCache - get tenant logo attachment by id")
			return nil, nil
		}
		response.CdnLogoURL = attachmentById.CdnUrl
	}

	return response, nil
}
