package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/model"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper"
	enummapper "github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper/enum"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/tracing"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/common"
	postgresentity "github.com/openline-ai/openline-customer-os/packages/server/customer-os-postgres-repository/entity"
)

// WorkflowUpdate is the resolver for the workflow_Update field.
func (r *mutationResolver) WorkflowUpdate(ctx context.Context, input model.WorkflowUpdateInput) (*model.ActionResponse, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "MutationResolver.WorkflowUpdate", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.LogObjectAsJson(span, "input", input)

	tenant := common.GetTenantFromContext(ctx)
	span.SetTag(tracing.SpanTagTenant, tenant)

	// prepare workflow id
	workflowId, err := strconv.ParseUint(input.ID, 10, 64)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to update workflow")
		return &model.ActionResponse{Accepted: false}, nil
	}

	// get workflow before update
	workflowBeforeUpdate, err := r.Services.Repositories.PostgresRepositories.WorkflowRepository.GetWorkflowByTenantAndId(ctx, tenant, workflowId)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Workflow not found")
		return &model.ActionResponse{Accepted: false}, nil
	}

	// update workflow
	err = r.Services.Repositories.PostgresRepositories.WorkflowRepository.UpdateWorkflow(ctx, workflowId, input.Name, input.Condition, input.Live)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to update workflow")
		return &model.ActionResponse{Accepted: false}, nil
	}

	// if set live, execute workflow
	if !workflowBeforeUpdate.Live && input.Live != nil && *input.Live {
		// execute workflow
		// convert workflow id to int
		err = r.Services.CommonServices.WorkflowService.ExecuteWorkflow(ctx, tenant, workflowId)
		if err != nil {
			tracing.TraceErr(span, err)
			return &model.ActionResponse{Accepted: true}, nil
		}

	}

	return &model.ActionResponse{Accepted: true}, nil
}

// WorkflowByType is the resolver for the workflow_ByType field.
func (r *queryResolver) WorkflowByType(ctx context.Context, workflowType model.WorkflowType) (*model.Workflow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "QueryResolver.WorkflowByType", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.LogObjectAsJson(span, "workflowType", workflowType)

	tenant := common.GetTenantFromContext(ctx)
	span.SetTag(tracing.SpanTagTenant, tenant)

	workflow, err := r.Services.Repositories.PostgresRepositories.WorkflowRepository.GetWorkflowByTypeIfExists(ctx, tenant, enummapper.MapWorkflowTypeFromModel(workflowType))
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to get workflow")
		return nil, nil
	}

	// if not found, create
	if workflow == nil {
		createdWorkflow, err := r.Services.Repositories.PostgresRepositories.WorkflowRepository.CreateWorkflow(ctx, &postgresentity.Workflow{
			Tenant:       tenant,
			WorkflowType: enummapper.MapWorkflowTypeFromModel(workflowType),
			Name:         "",
			Condition:    "",
			Live:         false,
		})
		if err != nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "Failed to create workflow")
			return nil, nil
		}
		return mapper.MapWorkflowToModel(createdWorkflow), nil
	}

	return mapper.MapWorkflowToModel(*workflow), nil
}

// Workflows is the resolver for the workflows field.
func (r *queryResolver) Workflows(ctx context.Context) ([]*model.Workflow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "QueryResolver.Workflows", graphql.GetOperationContext(ctx))
	defer span.Finish()

	tenant := common.GetTenantFromContext(ctx)
	span.SetTag(tracing.SpanTagTenant, tenant)

	workflows, err := r.Services.Repositories.PostgresRepositories.WorkflowRepository.GetWorkflows(ctx, tenant)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to get workflows")
		return nil, nil
	}

	// created workflow if missing in list
	expectedWorkflowTypes := postgresentity.AutoCreateWorkflowTypes

	for _, expectedWorkflowType := range expectedWorkflowTypes {
		found := false
		for _, workflow := range workflows {
			if workflow.WorkflowType == expectedWorkflowType {
				found = true
				break
			}
		}
		if !found {
			createdWorkflow, err := r.Services.Repositories.PostgresRepositories.WorkflowRepository.CreateWorkflow(ctx, &postgresentity.Workflow{
				Tenant:       tenant,
				WorkflowType: expectedWorkflowType,
				Name:         "",
				Condition:    "",
				Live:         false,
			})
			if err != nil {
				tracing.TraceErr(span, err)
				graphql.AddErrorf(ctx, "Failed to create workflow")
				return nil, nil
			}
			workflows = append(workflows, createdWorkflow)
		}
	}

	return mapper.MapWorkflowsToModels(workflows), nil
}
