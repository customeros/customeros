package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/dataloader"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/generated"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/model"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/tracing"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/common"
	neo4jentity "github.com/openline-ai/openline-customer-os/packages/server/customer-os-neo4j-repository/entity"
	opentracing "github.com/opentracing/opentracing-go"
)

// Contacts is the resolver for the contacts field.
func (r *flowResolver) Contacts(ctx context.Context, obj *model.Flow) ([]*model.FlowContact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Contacts", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := dataloader.For(ctx).GetFlowContactsForFlow(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		graphql.AddErrorf(ctx, "Failed to get flow sequence steps")
		return nil, nil
	}
	return mapper.MapEntitiesToFlowContacts(entities), nil
}

// User is the resolver for the user field.
func (r *flowActionSenderResolver) User(ctx context.Context, obj *model.FlowActionSender) (*model.User, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.User", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowActionSenderGetById(ctx, obj.Metadata.ID)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	if entity.UserId != nil {
		userEntity, err := r.Services.UserService.GetById(ctx, *entity.UserId)
		if err != nil || userEntity == nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "")
			return nil, err
		}
		return mapper.MapEntityToUser(userEntity), nil
	}

	return nil, nil
}

// Contact is the resolver for the contact field.
func (r *flowContactResolver) Contact(ctx context.Context, obj *model.FlowContact) (*model.Contact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Contact", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowContactGetById(ctx, obj.Metadata.ID)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	contactEntity, err := r.Services.ContactService.GetById(ctx, entity.ContactId)
	if err != nil || contactEntity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	return mapper.MapEntityToContact(contactEntity), nil
}

// FlowMerge is the resolver for the flow_Merge field.
func (r *mutationResolver) FlowMerge(ctx context.Context, input model.FlowMergeInput) (*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowMerge", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowMerge(ctx, mapper.MapFlowMergeInputToEntity(input))
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlow(entity), nil
}

// FlowChangeStatus is the resolver for the flow_changeStatus field.
func (r *mutationResolver) FlowChangeStatus(ctx context.Context, id string, status neo4jentity.FlowStatus) (*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowChangeStatus", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowChangeStatus(ctx, id, status)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlow(entity), nil
}

// FlowContactAdd is the resolver for the flowContact_Add field.
func (r *mutationResolver) FlowContactAdd(ctx context.Context, flowID string, contactID string) (*model.FlowContact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowContactAdd", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowContactAdd(ctx, flowID, contactID)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlowContact(entity), nil
}

// FlowContactAddBulk is the resolver for the flowContact_AddBulk field.
func (r *mutationResolver) FlowContactAddBulk(ctx context.Context, flowID string, contactID []string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowContactAddBulk", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	for _, id := range contactID {
		entity, err := r.Services.CommonServices.FlowService.FlowContactAdd(ctx, flowID, id)
		if err != nil || entity == nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "")
			return &model.Result{Result: false}, err
		}
	}
	return &model.Result{Result: true}, nil
}

// FlowContactDelete is the resolver for the flowContact_Delete field.
func (r *mutationResolver) FlowContactDelete(ctx context.Context, id string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowContactDelete", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	err := r.Services.CommonServices.FlowService.FlowContactDelete(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return &model.Result{Result: false}, err
	}
	return &model.Result{Result: true}, nil
}

// FlowContactDeleteBulk is the resolver for the flowContact_DeleteBulk field.
func (r *mutationResolver) FlowContactDeleteBulk(ctx context.Context, id []string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowContactDeleteBulk", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	for _, id := range id {
		err := r.Services.CommonServices.FlowService.FlowContactDelete(ctx, id)
		if err != nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "")
			return &model.Result{Result: false}, err
		}
	}
	return &model.Result{Result: true}, nil
}

// FlowSenderMerge is the resolver for the flowSender_Merge field.
func (r *mutationResolver) FlowSenderMerge(ctx context.Context, flowID string, input model.FlowActionSenderMergeInput) (*model.FlowActionSender, error) {
	panic(fmt.Errorf("not implemented: FlowSenderMerge - flowSender_Merge"))
}

// FlowSenderDelete is the resolver for the flowSender_Delete field.
func (r *mutationResolver) FlowSenderDelete(ctx context.Context, id string) (*model.Result, error) {
	panic(fmt.Errorf("not implemented: FlowSenderDelete - flowSender_Delete"))
}

// Flows is the resolver for the flows field.
func (r *queryResolver) Flows(ctx context.Context) ([]*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Flows", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := r.Services.CommonServices.FlowService.FlowGetList(ctx)
	if err != nil || entities == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntitiesToFlows(entities), nil
}

// Mailboxes is the resolver for the mailboxes field.
func (r *queryResolver) Mailboxes(ctx context.Context) ([]string, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Mailboxes", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := r.Services.Repositories.PostgresRepositories.TenantSettingsMailboxRepository.GetAll(ctx, common.GetTenantFromContext(ctx))
	if err != nil || entities == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	mailboxes := make([]string, 0)
	for _, entity := range entities {
		mailboxes = append(mailboxes, entity.MailboxUsername)
	}

	return mailboxes, nil
}

// Flow returns generated.FlowResolver implementation.
func (r *Resolver) Flow() generated.FlowResolver { return &flowResolver{r} }

// FlowActionSender returns generated.FlowActionSenderResolver implementation.
func (r *Resolver) FlowActionSender() generated.FlowActionSenderResolver {
	return &flowActionSenderResolver{r}
}

// FlowContact returns generated.FlowContactResolver implementation.
func (r *Resolver) FlowContact() generated.FlowContactResolver { return &flowContactResolver{r} }

type flowResolver struct{ *Resolver }
type flowActionSenderResolver struct{ *Resolver }
type flowContactResolver struct{ *Resolver }
