package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.53

import (
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/constants"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/dataloader"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/generated"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/model"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/tracing"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/common"
	commonService "github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/service"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/utils"
	neo4jentity "github.com/openline-ai/openline-customer-os/packages/server/customer-os-neo4j-repository/entity"
	neo4jenum "github.com/openline-ai/openline-customer-os/packages/server/customer-os-neo4j-repository/enum"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"
	"github.com/vektah/gqlparser/v2/ast"
)

// Organization is the resolver for the organization field.
func (r *invoiceResolver) Organization(ctx context.Context, obj *model.Invoice) (*model.Organization, error) {
	ctx = tracing.EnrichCtxWithSpanCtxForGraphQL(ctx, graphql.GetOperationContext(ctx))

	organizationEntity, err := dataloader.For(ctx).GetOrganizationForInvoice(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		r.log.Errorf("error fetching organization for invoice %s: %s", obj.Metadata.ID, err.Error())
		graphql.AddErrorf(ctx, "Error fetching organization for invoice %s", obj.Metadata.ID)
		return nil, nil
	}
	return mapper.MapEntityToOrganization(organizationEntity), nil
}

// Contract is the resolver for the contract field.
func (r *invoiceResolver) Contract(ctx context.Context, obj *model.Invoice) (*model.Contract, error) {
	ctx = tracing.EnrichCtxWithSpanCtxForGraphQL(ctx, graphql.GetOperationContext(ctx))

	contractEntity, err := dataloader.For(ctx).GetContractForInvoice(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		r.log.Errorf("error fetching contract for invoice %s: %s", obj.Metadata.ID, err.Error())
		graphql.AddErrorf(ctx, "Error fetching contract for invoice %s", obj.Metadata.ID)
		return nil, nil
	}
	return mapper.MapEntityToContract(contractEntity), nil
}

// InvoiceLineItems is the resolver for the invoiceLineItems field.
func (r *invoiceResolver) InvoiceLineItems(ctx context.Context, obj *model.Invoice) ([]*model.InvoiceLine, error) {
	ctx = tracing.EnrichCtxWithSpanCtxForGraphQL(ctx, graphql.GetOperationContext(ctx))

	entities, err := dataloader.For(ctx).GetInvoiceLinesForInvoice(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		r.log.Errorf("failed to get invoice lines for invoice %s: %s", obj.Metadata.ID, err.Error())
		graphql.AddErrorf(ctx, "Failed to fetch invoice lines for invoice %s", obj.Metadata.ID)
		return nil, nil
	}
	return mapper.MapEntitiesToInvoiceLines(entities), nil
}

// ContractLineItem is the resolver for the contractLineItem field.
func (r *invoiceLineResolver) ContractLineItem(ctx context.Context, obj *model.InvoiceLine) (*model.ServiceLineItem, error) {
	ctx = tracing.EnrichCtxWithSpanCtxForGraphQL(ctx, graphql.GetOperationContext(ctx))

	serviceLineItemEntity, err := dataloader.For(ctx).GetServiceLineItemForInvoiceLine(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		r.log.Errorf("Failed to get contract line item for invoice line %s: %s", obj.Metadata.ID, err.Error())
		graphql.AddErrorf(ctx, "Failed to get contract line items for invoice line %s", obj.Metadata.ID)
		return nil, nil
	}
	return mapper.MapEntityToServiceLineItem(serviceLineItemEntity), nil
}

// InvoiceNextDryRunForContract is the resolver for the invoice_NextDryRunForContract field.
func (r *mutationResolver) InvoiceNextDryRunForContract(ctx context.Context, contractID string) (string, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "InvoiceResolver.InvoiceNextInvoiceDryRun", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	span.LogFields(log.Object("request.contractID", contractID))

	invoiceId, err := r.Services.CommonServices.InvoiceService.NextInvoiceDryRun(ctx, contractID, constants.AppSourceCustomerOsApi)

	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to dry run next invoice for contract")
		return "", err
	}
	return invoiceId, nil
}

// InvoiceUpdate is the resolver for the invoice_Update field.
func (r *mutationResolver) InvoiceUpdate(ctx context.Context, input model.InvoiceUpdateInput) (*model.Invoice, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "MutationResolver.InvoiceUpdate", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	tracing.LogObjectAsJson(span, "request.input", input)

	err := r.Services.InvoiceService.UpdateInvoice(ctx, input)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to update invoice %s", input.ID)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: input.ID,
		}}, nil
	}
	invoiceEntity, err := r.Services.CommonServices.InvoiceService.GetById(ctx, input.ID)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed fetching invoice details. Invoice id: %s", input.ID)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: input.ID,
		}}, nil
	}

	return mapper.MapEntityToInvoice(invoiceEntity), nil
}

// InvoicePay is the resolver for the invoice_Pay field.
func (r *mutationResolver) InvoicePay(ctx context.Context, id string) (*model.Invoice, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "MutationResolver.InvoicePay", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	span.LogFields(log.String("request.id", id))

	invoice, err := r.Services.CommonServices.InvoiceService.GetById(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to fetch invoice %s", id)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	if invoice.DryRun {
		tracing.TraceErr(span, errors.New("invoice is a dry run"))
		graphql.AddErrorf(ctx, "Invoice is a dry run")
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	if invoice.Status != neo4jenum.InvoiceStatusDue {
		tracing.TraceErr(span, errors.New("invoice is not due"))
		graphql.AddErrorf(ctx, "Invoice is not due")
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	err = r.Services.CommonServices.InvoiceService.PayInvoice(ctx, id, constants.AppSourceCustomerOsApi)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to pay invoice %s", id)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}
	invoiceEntity, err := r.Services.CommonServices.InvoiceService.GetById(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed fetching invoice details. Invoice id: %s", id)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	return mapper.MapEntityToInvoice(invoiceEntity), nil
}

// InvoiceVoid is the resolver for the invoice_Void field.
func (r *mutationResolver) InvoiceVoid(ctx context.Context, id string) (*model.Invoice, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "MutationResolver.InvoiceVoid", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	span.LogFields(log.String("request.id", id))

	invoice, err := r.Services.CommonServices.InvoiceService.GetById(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to fetch invoice %s", id)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	if invoice.DryRun {
		tracing.TraceErr(span, errors.New("invoice is a dry run"))
		graphql.AddErrorf(ctx, "Invoice is a dry run")
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	if invoice.Status == neo4jenum.InvoiceStatusVoid {
		tracing.TraceErr(span, errors.New("invoice is already void"))
		graphql.AddErrorf(ctx, "Invoice is already void")
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	err = r.Services.CommonServices.InvoiceService.VoidInvoice(ctx, id, constants.AppSourceCustomerOsApi)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to void invoice %s", id)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}
	invoiceEntity, err := r.Services.CommonServices.InvoiceService.GetById(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed fetching invoice details. Invoice id: %s", id)
		return &model.Invoice{Metadata: &model.Metadata{
			ID: id,
		}}, nil
	}

	return mapper.MapEntityToInvoice(invoiceEntity), nil
}

// InvoiceSimulate is the resolver for the invoice_Simulate field.
func (r *mutationResolver) InvoiceSimulate(ctx context.Context, input model.InvoiceSimulateInput) ([]*model.InvoiceSimulate, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "InvoiceResolver.InvoiceSimulate", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	span.LogFields(log.Object("request.input", input))

	simulateInvoiceData := commonService.SimulateInvoiceRequestData{
		ContractId: input.ContractID,
	}
	for _, serviceLine := range input.ServiceLines {
		simulateInvoiceData.ServiceLines = append(simulateInvoiceData.ServiceLines, commonService.SimulateInvoiceRequestServiceLineData{
			Key:               serviceLine.Key,
			ServiceLineItemID: utils.IfNotNilString(serviceLine.ServiceLineItemID),
			ParentID:          utils.IfNotNilString(serviceLine.ParentID),
			Description:       serviceLine.Description,
			BillingCycle:      mapper.MapBilledTypeFromModel(serviceLine.BillingCycle),
			Price:             serviceLine.Price,
			Quantity:          serviceLine.Quantity,
			ServiceStarted:    serviceLine.ServiceStarted,
			TaxRate:           serviceLine.TaxRate,
			Canceled:          utils.IfNotNilBool(serviceLine.CloseVersion),
		})
	}

	nextInvoices, err := r.Services.CommonServices.InvoiceService.SimulateInvoice(ctx, &simulateInvoiceData)

	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to simulate invoice")
		return nil, err
	}

	var customer model.InvoiceCustomer
	var provider model.InvoiceProvider
	if len(nextInvoices) > 0 {
		// Get FieldContext from the ctx
		fc := graphql.GetFieldContext(ctx)
		requestedCustomerDtls := false
		requestedProviderDtls := false
		for _, selected := range fc.Field.Selections {
			if field, ok := selected.(*ast.Field); ok {
				if field.Name == "customer" {
					requestedCustomerDtls = true
				}
				if field.Name == "provider" {
					requestedProviderDtls = true
				}
			}
		}

		// populate customer data
		if requestedCustomerDtls {
			contract, err := r.Services.CommonServices.ContractService.GetById(ctx, input.ContractID)
			if err != nil {
				tracing.TraceErr(span, err)
				graphql.AddErrorf(ctx, "Failed to get contract by id %s", input.ContractID)
				return nil, err
			}
			customer = model.InvoiceCustomer{
				Name:            utils.StringPtr(contract.OrganizationLegalName),
				Email:           utils.StringPtr(contract.InvoiceEmail),
				AddressLine1:    utils.StringPtr(contract.AddressLine1),
				AddressLine2:    utils.StringPtr(contract.AddressLine2),
				AddressZip:      utils.StringPtr(contract.Zip),
				AddressLocality: utils.StringPtr(contract.Locality),
				AddressCountry:  utils.StringPtr(contract.Country),
				AddressRegion:   utils.StringPtr(contract.Region),
			}
		}

		// populate provider data
		if requestedProviderDtls {
			tenantBillingProfile, err := r.Services.CommonServices.TenantService.GetDefaultTenantBillingProfile(ctx)
			if err != nil {
				tracing.TraceErr(span, err)
				graphql.AddErrorf(ctx, "Failed to get tenant billing profile")
				return nil, err
			}
			tenantSettings, err := r.Services.CommonServices.TenantService.GetTenantSettings(ctx)
			if err != nil {
				tracing.TraceErr(span, err)
				graphql.AddErrorf(ctx, "Failed to get tenant settings")
				return nil, err
			}
			if tenantBillingProfile != nil {
				provider = model.InvoiceProvider{
					LogoRepositoryFileID: utils.StringPtr(tenantSettings.LogoRepositoryFileId),
					Name:                 utils.StringPtr(tenantBillingProfile.LegalName),
					AddressLine1:         utils.StringPtr(tenantBillingProfile.AddressLine1),
					AddressLine2:         utils.StringPtr(tenantBillingProfile.AddressLine2),
					AddressZip:           utils.StringPtr(tenantBillingProfile.Zip),
					AddressLocality:      utils.StringPtr(tenantBillingProfile.Locality),
					AddressCountry:       utils.StringPtr(tenantBillingProfile.Country),
					AddressRegion:        utils.StringPtr(tenantBillingProfile.Region),
				}
			}
		}
	}

	response := make([]*model.InvoiceSimulate, 0)
	for _, nextInvoice := range nextInvoices {
		invoice := model.InvoiceSimulate{
			Postpaid:           nextInvoice.Invoice.Postpaid,
			OffCycle:           nextInvoice.Invoice.OffCycle,
			InvoicePeriodStart: nextInvoice.Invoice.PeriodStartDate,
			InvoicePeriodEnd:   nextInvoice.Invoice.PeriodEndDate,
			Due:                nextInvoice.Invoice.DueDate,
			Issued:             nextInvoice.Invoice.IssuedDate,
			Currency:           nextInvoice.Invoice.Currency.String(),
			Note:               nextInvoice.Invoice.Note,
			Amount:             nextInvoice.Invoice.Amount,
			Subtotal:           nextInvoice.Invoice.Amount,
			TaxDue:             nextInvoice.Invoice.Vat,
			Total:              nextInvoice.Invoice.TotalAmount,
			InvoiceLineItems:   []*model.InvoiceLineSimulate{},
			Customer:           &customer,
			Provider:           &provider,
		}

		for _, line := range nextInvoice.Lines {
			invoiceLine := model.InvoiceLineSimulate{
				Key:         line.Id,
				Description: line.Name,
				Price:       line.Price,
				Quantity:    line.Quantity,
				Total:       line.TotalAmount,
				TaxDue:      line.Vat,
				Subtotal:    line.Amount,
			}
			invoice.InvoiceLineItems = append(invoice.InvoiceLineItems, &invoiceLine)
		}

		response = append(response, &invoice)
	}

	return response, nil
}

// Invoice is the resolver for the invoice field.
func (r *queryResolver) Invoice(ctx context.Context, id string) (*model.Invoice, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "InvoiceResolver.Invoice", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	span.LogFields(log.String("request.invoiceID", id))

	if id == "" {
		tracing.TraceErr(span, errors.New("missing invoice input id"))
		graphql.AddErrorf(ctx, "Missing invoice input id")
		return nil, nil
	}

	invoiceEntityPtr, err := r.Services.CommonServices.InvoiceService.GetById(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to get contract by id %s", id)
		return nil, err
	}
	return mapper.MapEntityToInvoice(invoiceEntityPtr), nil
}

// Invoices is the resolver for the invoices field.
func (r *queryResolver) Invoices(ctx context.Context, pagination *model.Pagination, where *model.Filter, sort []*model.SortBy, organizationID *string) (*model.InvoicesPage, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "InvoiceResolver.Invoices", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	if where != nil {
		tracing.LogObjectAsJson(span, "request.where", where)
	}
	if sort != nil {
		tracing.LogObjectAsJson(span, "request.sort", sort)
	}

	if pagination == nil {
		pagination = &model.Pagination{Page: 0, Limit: 0}
	}
	span.LogFields(log.Int("request.pagination.page", pagination.Page), log.Int("request.pagination.limit", pagination.Limit))

	paginatedResult, err := r.Services.InvoiceService.GetInvoices(ctx, utils.IfNotNilString(organizationID), pagination.Page, pagination.Limit, where, sort)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to get invoices")
		return nil, err
	}

	countInvoices, err := r.Services.InvoiceService.CountInvoices(ctx, common.GetTenantFromContext(ctx), utils.IfNotNilString(organizationID), where)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to get organizations and contacts data")
		return nil, nil
	}

	return &model.InvoicesPage{
		Content:        mapper.MapEntitiesToInvoices(paginatedResult.Rows.(*neo4jentity.InvoiceEntities)),
		TotalPages:     paginatedResult.TotalPages,
		TotalElements:  paginatedResult.TotalRows,
		TotalAvailable: countInvoices,
	}, err
}

// InvoiceByNumber is the resolver for the invoice_ByNumber field.
func (r *queryResolver) InvoiceByNumber(ctx context.Context, number string) (*model.Invoice, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "InvoiceResolver.InvoiceByNumber", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)
	span.LogFields(log.String("request.invoiceNumber", number))

	if number == "" {
		tracing.TraceErr(span, errors.New("missing invoice number"))
		graphql.AddErrorf(ctx, "Missing invoice number")
		return nil, nil
	}

	invoiceEntityPtr, err := r.Services.CommonServices.InvoiceService.GetByNumber(ctx, number)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "Failed to get invoice by number %s", number)
		return nil, err
	}
	return mapper.MapEntityToInvoice(invoiceEntityPtr), nil
}

// Invoice returns generated.InvoiceResolver implementation.
func (r *Resolver) Invoice() generated.InvoiceResolver { return &invoiceResolver{r} }

// InvoiceLine returns generated.InvoiceLineResolver implementation.
func (r *Resolver) InvoiceLine() generated.InvoiceLineResolver { return &invoiceLineResolver{r} }

type invoiceResolver struct{ *Resolver }
type invoiceLineResolver struct{ *Resolver }
