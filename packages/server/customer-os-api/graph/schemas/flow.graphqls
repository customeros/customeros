extend type Query {
    flows: [Flow!]! @hasRole(roles: [ADMIN, USER]) @hasTenant
    mailboxes: [String!]! @hasRole(roles: [ADMIN, USER]) @hasTenant
}

extend type Mutation {
    flow_Merge(input: FlowMergeInput!): Flow! @hasRole(roles: [ADMIN, USER]) @hasTenant
    flow_ChangeStatus(id: ID!, status: FlowStatus!): Flow! @hasRole(roles: [ADMIN, USER]) @hasTenant

    flowContact_Add(flowId: ID!, contactId: ID!): FlowContact! @hasRole(roles: [ADMIN, USER]) @hasTenant
    flowContact_AddBulk(flowId: ID!, contactId: [ID!]!): Result! @hasRole(roles: [ADMIN, USER]) @hasTenant
    flowContact_Delete(id: ID!): Result! @hasRole(roles: [ADMIN, USER]) @hasTenant

    flowAction_Merge(flowId: ID!, input: FlowActionMergeInput!): FlowAction! @hasRole(roles: [ADMIN, USER]) @hasTenant
    flowAction_ChangeIndex(id: ID!, index: Int64!): Result! @hasRole(roles: [ADMIN, USER]) @hasTenant
    flowAction_ChangeStatus(id: ID!, status: FlowActionStatus!): FlowAction! @hasRole(roles: [ADMIN, USER]) @hasTenant

    flowActionSender_Merge(flowActionId: ID!, input: FlowActionSenderMergeInput!): FlowActionSender! @hasRole(roles: [ADMIN, USER]) @hasTenant
    flowActionSender_Delete(id: ID!): Result! @hasRole(roles: [ADMIN, USER]) @hasTenant
}

#Flow
type Flow implements MetadataInterface {
    metadata:           Metadata!
    name:               String!
    description:        String!
    status: FlowStatus!
    actions: [FlowAction!]! @goField(forceResolver: true)
    contacts: [FlowContact!]! @goField(forceResolver: true)
}

input FlowMergeInput {
    id: ID
    name: String!
    description: String!
}

enum FlowStatus {
    INACTIVE
    ACTIVE
    PAUSED
    ARCHIVED
}

#FlowContact
type FlowContact implements MetadataInterface {
    metadata:               Metadata!

    contact: Contact! @goField(forceResolver: true)
}

#FlowAction
type FlowAction implements MetadataInterface {
    metadata: Metadata!

    index: Int64!
    name: String!
    status: FlowActionStatus!

    actionType: FlowActionType!
    actionData: FlowActionData!

    senders: [FlowActionSender!]! @goField(forceResolver: true)
}

enum FlowActionType {
    WAIT

    EMAIL_NEW
    EMAIL_REPLY

    LINKEDIN_CONNECTION_REQUEST
    LINKEDIN_MESSAGE
}

union FlowActionData = FlowActionDataWait | FlowActionDataEmail | FlowActionLinkedinConnectionRequest | FlowActionLinkedinMessage

type FlowActionDataWait {
    minutes: Int64!
}

type FlowActionDataEmail {
    replyToId: String
    subject: String!
    bodyTemplate: String!
}

type FlowActionLinkedinConnectionRequest {
    messageTemplate: String!
}

type FlowActionLinkedinMessage {
    messageTemplate: String!
}

input FlowActionMergeInput {
    id: ID
    name: String!
    actionType: FlowActionType!
    actionData: FlowActionInputData!
}

#FlowActionSender
type FlowActionSender implements MetadataInterface {
    metadata: Metadata!

    mailbox:    String
    emailsPerHour: Int64
    user: User @goField(forceResolver: true)
}

input FlowActionSenderMergeInput {
    id: ID

    #email action type
    mailbox: String
    emailsPerHour: Int64

    #linkedin action type
    userId: ID
}

input FlowActionInputData {
    wait: FlowActionInputDataWait

    email_new: FlowActionInputDataEmail
    email_reply: FlowActionInputDataEmail

    linkedin_connection_request: FlowActionInputDataLinkedinConnectionRequest
    linkedin_message: FlowActionInputDataLinkedinMessage
}
input FlowActionInputDataWait {
    minutes: Int64!
}

input FlowActionInputDataEmail {
    replyToId: String
    subject: String!
    bodyTemplate: String!
}

input FlowActionInputDataLinkedinConnectionRequest {
    messageTemplate: String!
}

input FlowActionInputDataLinkedinMessage {
    messageTemplate: String!
}

enum FlowActionStatus {
    INACTIVE
    ACTIVE
    PAUSED
    ARCHIVED
}