extend type Query {
    invoice(id: ID!): Invoice!
    invoices(pagination: Pagination, where: Filter, sort: [SortBy!], organizationId: ID): InvoicesPage!
}

extend type Mutation {
    invoice_NextDryRunForContract(contractId: ID!): ID!  @hasRole(roles: [ADMIN, USER]) @hasTenant
    invoice_Simulate(input: InvoiceSimulateInput!): ID!  @hasRole(roles: [ADMIN, USER]) @hasTenant
}

type InvoicesPage implements Pages {
    content: [Invoice!]!
    totalPages: Int!
    totalElements: Int64!
}

type Invoice implements MetadataInterface {
    metadata:           Metadata!
    id:                 ID! @deprecated(reason: "Use metadata instead.")
    createdAt:          Time! @deprecated(reason: "Use metadata instead.")
    updatedAt:          Time! @deprecated(reason: "Use metadata instead.")
    source:             DataSource! @deprecated(reason: "Use metadata instead.")
    sourceOfTruth:      DataSource! @deprecated(reason: "Use metadata instead.")
    appSource:          String! @deprecated(reason: "Use metadata instead.")

    organization:       Organization! @goField(forceResolver: true)
    dryRun:             Boolean!
    postpaid:           Boolean!
    offCycle:           Boolean!
    number:             String!
    periodStartDate:    Time!
    periodEndDate:      Time!
    dueDate:            Time!
    amount:             Float!
    vat:                Float!
    totalAmount:        Float!
    currency:           String!
    repositoryFileId:   String!
    invoiceLines:       [InvoiceLine!]! @goField(forceResolver: true)
    status:             InvoiceStatus
    note:               String
    domesticPaymentsBankInfo:       String
    internationalPaymentsBankInfo:  String
    customer:                   InvoiceCustomer!
    provider:                   InvoiceProvider!
}

type InvoiceCustomer {
    name:               String
    email:              String
    addressLine1:       String
    addressLine2:       String
    addressZip:         String
    addressLocality:    String
    addressCountry:     String
}

type InvoiceProvider {
    logoUrl:            String
    name:               String
    addressLine1:       String
    addressLine2:       String
    addressZip:         String
    addressLocality:    String
    addressCountry:     String
}

type InvoiceLine implements MetadataInterface {
    metadata:           Metadata!
    description:        String!
    price:              Float!
    quantity:           Int!
    subtotal:           Float!
    total:              Float!
    taxDue:             Float!

    id:                 ID! @deprecated(reason: "Use metadata instead.")
    createdAt:          Time! @deprecated(reason: "Use metadata instead.")
    name:               String! @deprecated(reason: "Use description instead.")
    amount:             Float! @deprecated(reason: "Use subtotal instead.")
    vat:                Float! @deprecated(reason: "Use taxDue instead.")
    totalAmount:        Float! @deprecated(reason: "Use total instead.")
}

type Tax {
    salesTax:   Boolean!
    vat:        Boolean!
    taxRate:    Float!
}

input InvoiceSimulateInput {
    contractId:         ID!
    periodStartDate:    Time
    periodEndDate:      Time
    invoiceLines:       [InvoiceLineInput!]!
}
input InvoiceLineInput {
    serviceLineItemId:  ID
    name:               String!
    billed:             BilledType!
    price:              Float!
    quantity:           Int!
}

enum InvoiceStatus {
    DRAFT
    DUE
    PAID
}